import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        maven { url = "https://plugins.gradle.org/m2/" }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
    }
}
apply plugin: 'java'
apply plugin: 'net.minecraftforge.gradle'
// Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
apply plugin: 'eclipse'

version = "4.0"
if (inCI()) {
    // In remote CI/CD environment
    version = (version + "_" + System.getenv("GITHUB_SHA").substring(0, 7))
}
group = 'com.kotori316' // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = 'Marker'

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
    mappings channel: 'snapshot', version: '20190719-1.14.3'
    runs {
        client {
            workingDirectory project.file('Minecraft')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                flexiblemarker {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run-server')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'info'

            mods {
                flexiblemarker {
                    source sourceSets.main
                }
            }
        }
    }
}
repositories {
    if (hasGitHubToken()) {
        maven {
            name = "GitHub Quarry Repository"
            url = uri("https://maven.pkg.github.com/Kotori316/QuarryPlus")
            credentials {
                username = project.findProperty("gpr.user") ?: System.getenv("GITHUB_ACTOR") ?: ""
                password = project.findProperty("githubToken") ?: System.getenv("REPO_TOKEN") ?: ""
            }
        }
    } else {
        maven {
            // Location of QuarryPlus
            name 'curseforge'
            url 'https://minecraft.curseforge.com/api/maven/'
        }
    }
}

private boolean hasGitHubToken() {
    return project.hasProperty("githubToken") || System.getenv("REPO_TOKEN") != null
}

dependencies {
    def forge_prop = loadProperties("forge_version.properties")
    minecraft(forge_prop.getProperty("forge_version"))
    if (hasGitHubToken()) {
        implementation(fg.deobf("com.kotori316:AdditionalEnchantedMiner:${forge_prop.getProperty("quarry_version")}"))
    } else {
        implementation fileTree(dir: 'library', include: '**/*.jar')
    }

    // Test Dependencies.
    testCompile("org.junit.jupiter:junit-jupiter-api:5.4.2")
    testRuntime("org.junit.jupiter:junit-jupiter-engine:5.4.2")
}

jar {
    def timeFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssZ")
    manifest {
        attributes([
                "Specification-Title"     : project.name,
                "Specification-Vendor"    : "Kotori316",
                "Specification-Version"   : "1", // We are version 1 of ourselves
                "Implementation-Title"    : project.name,
                "Implementation-Version"  : "${version}",
                "Implementation-Vendor"   : "Kotori316",
                "Implementation-Timestamp": ZonedDateTime.now().format(timeFormat)
        ])
    }
}

task srcJar(type: Jar) {
    from sourceSets.main.allSource
    classifier = 'sources'
}

task deobfJar(type: Jar) {
    from sourceSets.main.output
    classifier = 'deobf'
}

def loadProperties(String filename) {
    def props = new Properties()
    file(filename).withInputStream {
        props.load(it)
    }
    return props
}

// Tell the artifact system about our extra jars
artifacts {
    archives srcJar, deobfJar
}

test {
    useJUnitPlatform()
}

task signJar2() {
    doLast {
        ant.signjar(
                jar: jar.archivePath,
                alias: project.hasProperty('keyStoreAlias') ? project.getProperty('keyStoreAlias') : "",
                keystore: project.hasProperty('keyStore') ? project.getProperty("keyStore") : "",
                storepass: project.hasProperty('keyStorePass') ? project.getProperty('keyStorePass') : "",
                sigalg: "SHA1withRSA",
                digestalg: "SHA-256",
                tsaurl: "http://timestamp.digicert.com"
        )
    }
}

if (!inCI()) {
    // Runs this task automatically when build is ran.
    assemble.dependsOn(signJar2)
}

private static boolean inCI() {
    Boolean.valueOf(System.getenv("GITHUB_ACTIONS"))
}

task checkParamater() {
    doLast {
        println "Has GitHub Token: ${hasGitHubToken()}"
        println "In CI:  ${inCI()}"
    }
}
